
    %:LLPStartPreview para rodar o pdf com mudancas automaticas

\documentclass[12pt, a4paper]{article}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel} % Separacao de silabas em portugues
\usepackage{amsthm} % has proof
\usepackage{amsmath}
\usepackage{listings}
\usepackage{tcolorbox}
\usepackage {tikz}
\usepackage{hyperref}
\usepackage{float}
\usetikzlibrary {positioning}
\usetikzlibrary{arrows}
%\usepackage {xcolor}

\tikzset{edge/.style = {->,> = latex'}}

    \graphicspath{
    {.} % document root dir
    {./img/}
}

\renewcommand\refname{Referências}
\newtheorem{theorem}{Teorema}[section]
\newtheorem{corollary}{Corolário}
\newtheorem{lemma}{Lema}

\title{O problema do carteiro chinês}
\author{Carlos Eduardo Ferreira\\Gabriel Fernandes de Oliveira}
\date{}

\begin{document}

\maketitle

    \section{Problemas resolvidos}

        Esta seção se dedica a discutir aplicações da teoria apresentada no trabalho em competições de programação.

        \subsection{Tanya and Password\cite{tanya}}

        Este problema fornece um conjunto $\mathcal{C}$ de $n$ strings de tamanho 3 e pede para que construa-se, se possível, uma string $S$ de tamanho $n+2$ com arestrição de que o conjunto das substrings de tamanho 3 da string $S$ deve corresponder a $\mathcal{C}$.

        Um exemplo desse problema é o seguinte, para $n=5$:

        \[\mathcal{C} = \{aca, aba, aba, cab, bac\}\]

        Uma string $S$ que resolve este exemplo é $abacaba$, já que toda substring de tamanho 3 de $S$ possui uma correspondência em $\mathcal{C}$.

        A solução que será apresentada para este problema envolve a teoria de caminhos eulerianos apresentada:

        Iniciaremos por explicar a modelagem realizada. Cada vértice do digrafo que construiremos representará um conjunto de duas letras. 
        
        Representaremos cada string $w \in \mathcal{C}$ por dois vértices ligados por um arco. Um dos vértices, que chamaremos de $u$, representa os dois primeiros caracteres de $w$, enquanto que o segundo vértice, $v$, representa os dois últimos caracteres de $w$, cria-se ainda um arco de $u$ a $v$.

        Para exemplificar tal procedimento tome $w = aca$. Criam-se primeiramente dois vértices, um representando a string $ac$ e outro representando $ca$, e liga-se ambos com um arco, como representado em \ref{fig:tanya}.

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[node distance=3cm, every loop/.style={},thick,main node/.style={circle,draw,font=\sffamily\Large}]

                \node[main node] (ac) {ac};
                \node[main node] at (2, 0) (ca) {ca};

                \path[->] (ac) edge[] node {} (ca);
            \end{tikzpicture}

            \caption{Exemplo da modelagem usada na solução}
            \label{fig:tanya}
        \end{figure}

        Deve repetir-se tal procedimento para toda string $w \in \mathcal{C}$. Segue a modelagem completa, que chamaremos de $G$, do exemplo inicial ($\mathcal{C} = \{aca, aba, aba, cab, bac\}$):
       

        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[node distance=3cm, every loop/.style={},thick,main node/.style={circle,draw,font=\sffamily\Large}]

                \node[main node] (ac) {ac};
                \node[main node] at (2, 0) (ca) {ca};
                \node[main node] at(0, -2) (ab) {ab};
                \node[main node] at(2, -2) (ba) {ba};


                \path[->] (ac) edge[] node {} (ca);
                \path[->] (ab) edge[bend left] node {} (ba);
                \path[->] (ab) edge[bend right] node {} (ba);
                \path[->] (ca) edge[] node {} (ab);
                \path[->] (ba) edge[] node {} (ac);
            \end{tikzpicture}
        \end{figure}


        Cada arco criado na modelagem corresponde a uma string de $\mathcal{C}$, o arco entre $ac$ e $ca$, por exemplo, representa a string $aca$.
        A partir dessa correspondência podemos representar também um passeio, $P$, em $G$ como uma sequência de strings, $seq$, de $\mathcal{C}$:

        O passeio $P = \{ba, ac, ca, ab\}$, por exemplo, percorre os arcos que correspondem à sequência $seq = \{bac, aca, cab\}$.

        Por sua vez, a partir de $seq$ é possível montar uma string $S$ que possua todas strings de $seq$ como substrings:

        \[seq = \{bac, aca, cab\} \rightarrow S = ``bacab'' \]

        Tal procedimento permite que, a partir de um passeio $P$ em $G$ construa-se uma string $S$ tal que:
        
        \begin{itemize}
            \item O tamanho de $S$ é igual ao número de arcos de $P$ mais 2;
            \item Se um arco $e$ está presente em $P$, então a string de $\mathcal{C}$ que $e$ representa será uma substring de $S$.
        \end{itemize}

        Como o problema pede que encontremos uma string de tamanho $n+2$ que possua todas strings de $\mathcal{C}$ como substrings, basta encontrar, se existir, uma trilha que percorra todo arco de $G$ uma única vez, isto é, uma trilha ou um circuito euleriano.

        Deste modo a solução do problema consiste em checar as propriedades necessárias para a existência de uma trilha euleriana [ADICONAR referencia ao corolario].

        Se uma trilha ou circuito euleriano existir em $G$, podemos usar o algoritmo de Hierholzer para encontrar tal passeio.

        Esta solução foi implementada em C++ e adicionada à referência\cite{tanya-sol}.

	\medskip

	\begin{thebibliography}{9}
	\bibitem{konigsberg} 
	Euler, Leonhard
	\textit{Solution problematis ad geometriam situs pertinentis}. 
	Comment. Acad. Sci. U. Petrop 8, 128–40, 1736.

	\bibitem{hierholzer}
	Hierholzer, Carl
	\textit{``Über die Möglichkeit, einen Linienzug ohne Wiederholung und ohne Unterbrechung zu umfahren''}, 
	Mathematische Annalen, 6 (1): 30–32, doi:10.1007/BF01442866, 1873.

    \bibitem{tanya}
    Problema D do round \#288 (Div. 2) retirado do Codeforces\\
    \href{https://codeforces.com/contest/508/problem/D}{codeforces.com/contest/508/problem/D}

    \bibitem{tanya-sol}
    Solução para o problema Tanya and Password, desenvolvida em C++\\
    \href{https://github.com/gafeol/competitive-programming/blob/master/ojs/cf/508/D.cpp}{github.com/gafeol/competitive-programming/blob/master/ojs/cf/508/D\\.cpp}

    \bibitem{sereja}
    Problema C do round \#215 (Div. 1) retirado do Codeforces\\
    \href{https://codeforces.com/problemset/problem/367/C}{codeforces.com/problemset/problem/367/C}

    \bibitem{sereja-sol}
    Solução para o problema Sereja and the Arrangement of Numbers, desenvolvida em C++\\
    \href{https://github.com/gafeol/competitive-programming/blob/master/ojs/cf/367/C.cpp}{github.com/gafeol/competitive-programming/blob/master/ojs/cf/367/C.cpp}

    \bibitem{jogging}
    Problema 10296 retirado do UVa\\
    \href{https://onlinejudge.org/index.php?option=com_onlinejudge&Itemid=8&page=show_problem&problem=1237}{onlinejudge.org/index.php?option=com\_onlinejudge\&Itemid=8\&page=show\\\_problem\&problem=1237}

    \bibitem{jogging-sol}
    Solução para o problema Jogging Trails, desenvolvida em C++\\
    \href{https://github.com/gafeol/competitive-programming/blob/master/ojs/UVa/1237.cpp}{github.com/gafeol/competitive-programming/blob/master/ojs/UVa/1237.cpp} 


    \bibitem{mit}
    Exemplo retirado do site do MIT, exercício 6.6.c\\
    \href{http://web.mit.edu/urban_or_book/www/book/chapter6/problems6/6.6.html}{web.mit.edu/urban\_or\_book/www/book/chapter6/problems6/6.6.html} 
	\end{thebibliography}
 
\end{document}
