    %:LLPStartPreview para rodar o pdf com mudancas automaticas

\documentclass[12pt, a4paper]{article}
\usepackage{graphicx}
\usepackage{wrapfig}
    \usepackage[utf8]{inputenc}
\usepackage[brazil]{babel} % Separacao de silabas em portugues
\usepackage{amsthm} % has proof
\usepackage{amsmath}
\usepackage{listings}
\usepackage{tcolorbox}
\usepackage {tikz}
\usepackage{hyperref}
\usepackage{float}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usetikzlibrary {positioning}
\usetikzlibrary{arrows}
%\usepackage {xcolor}

\algrenewcommand\algorithmicend{\textbf{fim}}
\algrenewcommand\algorithmicdo{\textbf{faça}}
\algrenewcommand\algorithmicwhile{\textbf{enquanto}}
\algrenewcommand\algorithmicfor{\textbf{para}}
\algrenewcommand\algorithmicif{\textbf{se}}
\algrenewcommand\algorithmicthen{\textbf{então}}
\algrenewcommand\algorithmicelse{\textbf{senão}}
\algrenewcommand\algorithmicreturn{\textbf{devolve}}
\algrenewcommand\algorithmicfunction{\textbf{função}}
\algrenewcommand\algorithmicprocedure{\textbf{procedimento}}


\tikzset{edge/.style = {->,> = latex'}}

    \graphicspath{
    {.} % document root dir
    {./img/}
}

\renewcommand\refname{Referências}
\newtheorem{theorem}{Teorema}[section]
\newtheorem{corollary}{Corolário}
\newtheorem{lemma}{Lema}

\title{O problema do carteiro chinês}
\author{Orientador: Carlos Eduardo Ferreira\\Gabriel Fernandes de Oliveira}
\date{}

\begin{document}

\maketitle


\newpage
\tableofcontents
\newpage


\section{Grafos eulerianos}

\subsection{Soluções}

% Referencia pra explicacao e https://cp-algorithms.com/graph/euler_path.html

\subsubsection{Algoritmo de Hierholzer}

O algoritmo de Hierholzer foca em encontrar e unir um conjunto de circuitos $C_1, C_2, \dots, C_k$, tal que não existe aresta pertencente a dois circuitos diferentes, e que toda aresta pertence ao menos a um circuito.
Tal união gera um circuito euleriano.

O algoritmo desenvolvido se baseia em percorrer o grafo euleriano com uma busca em profundidade, apagando todas as arestas percorridas nesta busca.
Quando o vértice atual da busca não possui mais arestas para se percorrer, o mesmo é adicionado ao começo da trilha euleriana que está sendo construída.

Segue o pseudo código do algoritmo de hierholzer para encontrar uma trilha euleriana dado um grafo euleriano.

\begin{algorithm}
\caption{Solução de Hierholzer}\label{eulerian-hierholzer}
\begin{algorithmic}[1]
\Function{euler\_hierholzer}{u}
\For{\textbf{cada} v em adj[u]}
    \State \textbf{apaga} a aresta de $u$ a $v$
    \State EULER\_HIERHOLZER($v$)
\EndFor
\State Insere $u$ no início de $trilha\_euleriana$
\EndFunction
\end{algorithmic}
\end{algorithm}

Digamos que a função apresentada seja chamada com um vértice inicial $v$, pertencente a um grafo euleriano $G$. A busca segue visitando vértices e apagando arestas até chegar no primeiro vértice em que não existem mais arestas para se percorrer. 

Em grafos que possuem um circuito euleriano, tal vértice será o próprio vértice inicial $v$, e podemos chamar o circuito formado de $C_1$.
Enquanto que, grafos que possuem apenas uma trilha euleriana, tal vértice será aquele cujo grau de entrada é maior que o grau de saída.

Em ambos casos, após encontrar tal vértice sem arestas, a função retorna por todos os vértices percorridos, procurando algum que ainda possua arestas não percorridas, para que ela possa encontrar um novo circuito $C_i$ e juntar o mesmo ao circuito, ou trilha, inicial, unindo ambas estruturas. 

Apesar da união dos circuitos ser um procedimento complexo e possivelmente custoso, não é necessário manter o resultado de todas uniões a serem realizados durante o algoritmo, já que apenas estamos interessados no resultado final, a trilha euleriana.
Para manter tal trilha, basta adicionar a uma pilha todo vértice encontrado na busca quando o mesmo não possui mais arestas a serem percorridas.

Segue agora a implementação deste algoritmo em C++:

\lstinputlisting[language=c++]{euler_hierholzer.cpp}

Optou-se nesta implementação o uso de uma pilha para o armazenamento da lista de adjacências $adj$, pois assim é possível apagar facilmente as arestas já percorridas na busca.

Para que tal função retorne corretamente uma trilha euleriana é necessário que a primeira chamada de $euler\_hierholzer$ tenha como parâmetro um vértice de grau ímpar, no caso dos grafos não direcionados, ou o vértice cujo grau de saída é maior que seu grau de entrada, no caso dos digrafos sem circuito euleriano.

Como em cada iteração deste algoritmo uma aresta é deletada, o número máximo de iterações que ele pode realizar é limitado pelo número de arestas de um grafo, sendo assim o mesmo possui complexidade $\mathcal{O}(|E|)$.

\end{document}
